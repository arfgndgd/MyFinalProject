--Kütüphaneler

-DataAccess
-Core(.net core ile ilgisi yok)
EntityFrameworkCore.SqlServer


--ADIMLAR


Katmanları aç
Classları belirle
Katmanlara Abstract ve Concrete klasörlerini aç

DataAcces
Abstract classları aç 
IEntityRepository interfacei miras vermeli (Generic Repository pattern uygula)

Concrete classları aç
EntityFramework
Entities classlarını implement et
Context classını yaz/veritabanı bağlantısını yaz
Entities classlarında implement edilen metodları doldur

Business
Abstract metod ekle
Concrete classta metodları düzenle

Core **bu katman referans almaz
(tüm projelerde kullanabileceğimiz bir alt yapı) (.net core ile bir ilgisi yok) (bu katman ilk başta açılsa daha iyi)
DataAccess klasörü aç / IEntityRepository classını buraya taşıdık 
Entities klasörü aç / IEntity classını buraya taşıdık 
(namespaceleri düzenle, Entities katmanındaki usingleri de düzenle)
EfEntityRepositoryBase classını EntityFramework klasörüne ekledik
	Bu class için DataAccess içinde Concrete classlarımızdaki metodları ortak bir çatıda topladık

DataAccess
Core'dan referans alıyoruz
Abstract classların usingleri düzenlenmeli
Concrete classlara Core projesinden EfEntityRepositoryBase mirası veriyoruz. <hangi class için, hangi veritabanına göre>, abstractı kim

Entities
DTOs klasörü açtık burada T-Sql join gibi operasyonlar için 
İlgili entityler göre dto classları açıyoruz
Çıplak class kalmaması için Dto classlarına miras verebilecek Core projesi içinde bir interface IDto classı açtık.

DataAccess
IProductDal içerisine DTO classımıza özel entity classın detaylarını getirecek bir List<ProductDetailDto> GetProductDetails(); metodu yazdık 
EfProductDal içerisinde ise implement ettik

Business
IProductService içine de aynı methodu yazdık, Manager classında implement ettik

Core
Utilities klasörü aç
Results klasörü aç(işlem sonuçları için mesaj, başarılı gibi geri bildirimler...)
IResult interfacei açtık (success, message..) get; readOnly metodları yazdık
Result classı açtık miras alıp implement ettik. get; readOnly

Business
IResult kullandığımız için Service classında "voidli metodu" IResult'a çevirdik
Manager classında metodu düzenliyoruz çünkü geriye değer döndürmesi gerekir. 
Alınan hata için de Result classına mesaj için constructor eklememiz gerekir.
Aşağıdaki satırdaki Result classlarına göre de metodu düzenle

Core
Alınan hata için de Result classına mesaj için constructor eklememiz gerekir.
Result classından miras alacak SuccessResult ve ErrorResult classlarını aç

Business
Constant(sabitler) klasörü aç (mesajlar,enumlar vs gibi sabitler)
Messages classı aç (static; class, method)
Manager classındaki methodlara Mesaj classını ekle

Service classında void olmayan metodlar için List<class> 'dan önce Core\Results klasörüne açtığımız IDataResult interfaceini ekleyerek hem mesaj hem değer döndüreceğiz(IResult'tan miras almalı)

Core 
IDataResult içinde geriye değer döndüren bi yapı kurmak için <T> generic yapı kullanacağız
DataResult classı açıp implement edip constructor yazıyoruz
	**Result classı void metodlar için success ve mesaj döndürür
	**DataResult classı success,message ve data döndürür

Alınan hata için de DataResult classına mesaj için constructor eklememiz gerekir.
Result classından miras alacak SuccessDataResult ve ErrorDataResult classlarını aç

Business
DataResult için implementleri düzenle
Manager classındaki methodlara Mesaj classını ekle

Api 
New Project/asp.net core web api
Controller ekle/ProductsController (Apide controller çoğul olarak isimlendirilir)
Action ekle

IoC Container yapısını kur (projemizde new edilen yapı yok configuration olmalı)
	 Startup.cs içinde ConfigureServices/services.AddSingleton<IProductService,ProductManager>();
										 services.AddSingleton<IProductDal,EfProductDal>()
										 
Business
Autofac-Autofac.Extras.DynamicProxy
DependencyResolvers klasörü aç
Autofac klasörü aç
AutofacBusinessModule classı aç
: Module (using Autofac)

WebApi
Startup.cs içinde AddSingleton'ları yorum satıra aldık. 
Program.cs içinde CreateHostBuilder metoduna .UseServiceProviderFactory(new AutofacServiceProviderFactory()) ekle
(IoC yapısı yerine Autofac kullan diyoruz)
											 .ConfigureContainer<ContainerBuilder> (yazdığımız modülü ekliyoruz)			

	****Autofac'ten vazgeçmek istediğimizde yeni yapımızı DependencyResolvers içine kurup Program.cs'te yeni yapılarımızı new'lesek yeterli olacaktır.
	

BUSINESS (FluentValidation/Manage NuGet)
Validation/doğrulama ekleyeceğiz  
ValidationRules/FluentValidation files/ProductValidator class
Validationlarımızı buraya constructor içine yazacağız / productManager içinde ise add metodunda karşılıyoruz

CORE
CrossCuttingConcerns/Validation/ValidationTool class
ProductManager/ Add metodundan validationı al yukarıdaki classa ekle

Utilities/Interceptors/(EnginDemirog github'tan aldık 3 class var)

	**Burada yazdığımız classlar sayesinde projemizin çalışma bekli değişecek. Yani bizim tüm metodlarımızın çalışmasından önce bu classlardaki metodlar çalışacak, önceliği belirlenecek, durumlarına göre try catch yapılarına girecek.

Aspect/Autofac/Validation files/(EnginDemirog github'tan)

Business
DependencyResolvers/Autofac
	AutofacBusinessModule içine Interceptorsa göre bir yapı ekledik 
Concrete classlarımız için (Product/Add metodu validation yorum satırı)
CSS/DatabaseLogger,FileLogger,ILogger 
ProductManager/ILoggerı constructora ekle (Dependency Injection)
AutofacBusinessModule > builder ekle ILogger, FileLogger